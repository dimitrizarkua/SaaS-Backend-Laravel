<?php

namespace Tests\Unit\LaravelJobs\Messages;

use App\Components\Documents\Interfaces\DocumentsServiceInterface;
use App\Components\Documents\Models\Document;
use App\Components\Messages\Enums\MessageParticipantTypes;
use App\Components\Messages\Interfaces\MessagingServiceInterface;
use App\Components\Messages\Models\Message;
use App\Jobs\Jobs\FindOrCreateOrActivateJobForIncomingMessage;
use App\Jobs\Messages\HandleIncomingJobMessage;
use Illuminate\Container\Container;
use Illuminate\Support\Facades\Queue;
use Tests\TestCase;

/**
 * Class HandleIncomingJobMessageTest
 *
 * @package Tests\Unit\LaravelJobs\Messages
 */
class HandleIncomingJobMessageTest extends TestCase
{
    /**
     * @var MessagingServiceInterface
     */
    private $messagingService;

    /**
     * @var \Mockery\MockInterface|DocumentsServiceInterface
     */
    private $documentsService;

    /**
     * Creates RFC 822 address.
     *
     * @param string      $address
     * @param null|string $display
     *
     * @return string
     */
    private function makeRFC822Address(string $address, ?string $display = null): string
    {
        return $display ? sprintf('%s <%s>', $display, $address) : $address;
    }

    /**
     * Helper method that generates exact or random number of recipients.
     *
     * @param int|null $count Number of recipients to be generated.
     *
     * @return array
     */
    private function makeRecipients(int $count = null): array
    {
        if (null === $count) {
            $count = $this->faker->numberBetween(1, 5);
        }

        $result = [];

        for ($i = 0; $i < $count; $i++) {
            $result[] = [
                'address' => $this->faker->email,
                'display' => $this->faker->optional()->name,
            ];
        }

        return $result;
    }

    /**
     * Helper method that converts array generated by ::makeRecipients() method to RFC 822 string.
     *
     * @param array $recipients Recipients.
     *
     * @return string
     */
    private function recipientsToRFC822String(array $recipients): string
    {
        $result = [];
        foreach ($recipients as $recipient) {
            $result[] = $this->makeRFC822Address($recipient['address'], $recipient['display']);
        }

        return implode(',', $result);
    }

    /**
     * Helper method that generates exact or random number of attachments.
     *
     * @param int|null $count Number of attachments to be generated.
     *
     * @return array|null
     */
    private function makeAttachments(int $count = null): ?array
    {
        if (null === $count) {
            $count = $this->faker->numberBetween(0, 5);
        }

        if ($count <= 0) {
            return null;
        }

        $result = [];

        for ($i = 0; $i < $count; $i++) {
            $result[] = [
                'size'         => $this->faker->numberBetween(64, 65536),
                'url'          => $this->faker->url,
                'name'         => $this->faker->uuid . '.' . $this->faker->fileExtension,
                'content-type' => $this->faker->mimeType,
            ];
        }

        return $result;
    }

    /**
     * @inheritdoc
     */
    public function setUp()
    {
        parent::setUp();

        $this->messagingService = Container::getInstance()
            ->make(MessagingServiceInterface::class);

        $this->documentsService = \Mockery::mock(DocumentsServiceInterface::class);
    }

    /**
     * @inheritdoc
     */
    protected function tearDown()
    {
        unset($this->messagingService, $this->documentsService);

        parent::tearDown();
    }

    /**
     * @throws \JsonMapper_Exception
     * @throws \Throwable
     */
    public function testSuccessfulHandling()
    {
        $senderEmail = $this->faker->email;

        // Make faker generate name without titles and suffixes
        $senderName = $this->faker->boolean ? $this->faker->firstName . ' ' . $this->faker->lastName : null;
        $from = $this->makeRFC822Address($senderEmail, $senderName);

        $toRecipients = $this->makeRecipients();
        $ccRecipients = $this->faker->boolean ? $this->makeRecipients() : null;

        $recipientEmail = $toRecipients[0]['address'];
        $externalMessageId = $this->faker->uuid . '@' . $this->faker->domainName;

        $headers = [
            ['Message-Id', '<' . $externalMessageId . '>'],
            ['To', $this->recipientsToRFC822String($toRecipients)],
        ];
        if (null !== $ccRecipients) {
            $headers[] = ['Cc', $this->recipientsToRFC822String($ccRecipients)];
        }

        $attachments = $this->makeAttachments();

        $data = [
            'timestamp'          => (int)$this->faker->dateTime()->format('U'),
            'token'              => $this->faker->sha1,
            'signature'          => $this->faker->sha256,
            'domain'             => $this->faker->domainName,
            'subject'            => null,
            'sender'             => $senderEmail,
            'from'               => $from,
            'recipient'          => $recipientEmail,
            'body_plain'         => $this->faker->paragraph,
            'body_html'          => $this->faker->randomHtml(),
            'stripped_text'      => $this->faker->paragraph,
            'stripped_signature' => $this->faker->optional()->sentence,
            'stripped_html'      => $this->faker->optional()->randomHtml(),
            'message_headers'    => \GuzzleHttp\json_encode($headers),
        ];
        if (null !== $attachments) {
            $data['attachments'] = \GuzzleHttp\json_encode($attachments);

            $this->documentsService
                ->shouldReceive('createDocumentFromUrl')
                ->times(count($attachments))
                ->andReturnUsing(function ($url, $originalFileName, $mimeType) {
                    $data = [
                        'storage_uid' => $this->faker->uuid,
                        'file_name'   => $originalFileName,
                        'file_size'   => $this->faker->numberBetween(64, 65535),
                        'file_hash'   => $this->faker->sha256,
                        'mime_type'   => $mimeType,
                    ];

                    $document = factory(Document::class)->create($data);

                    return $document;
                });
        }

        Queue::fake();

        $job = new HandleIncomingJobMessage($data);

        $job->handle($this->messagingService, $this->documentsService);

        /** @var Message $message */
        $message = Message::query()->where('external_system_message_id', $externalMessageId)
            ->firstOrFail();

        self::assertEquals($senderEmail, $message->from_address);
        self::assertEquals($senderName ?? $senderEmail, $message->from_name);
        self::assertEquals($data['subject'], $message->subject);
        self::assertEquals($data['stripped_text'], $message->message_body);

        Queue::assertPushedOn(
            'jobs',
            FindOrCreateOrActivateJobForIncomingMessage::class,
            function (FindOrCreateOrActivateJobForIncomingMessage $job) use ($message) {
                return $job->getMessageId() === $message->id;
            }
        );

        // Validating TO and CC recipients

        foreach ($toRecipients as $attachment) {
            $message->recipients()
                ->where([
                    'type'    => MessageParticipantTypes::TO,
                    'address' => $attachment['address'],
                ])
                ->firstOrFail();
        }

        if (!empty($ccRecipients)) {
            foreach ($ccRecipients as $attachment) {
                $message->recipients()
                    ->where([
                        'type'    => MessageParticipantTypes::CC,
                        'address' => $attachment['address'],
                    ])
                    ->firstOrFail();
            }
        }

        // Validating attachments (if any)

        if (!empty($attachments)) {
            self::assertCount(count($attachments), $message->documents);

            foreach ($attachments as $attachment) {
                $message->documents()
                    ->where([
                        'file_name' => $attachment['name'],
                        'mime_type' => $attachment['content-type'],
                    ])
                    ->firstOrFail();
            }
        }
    }

    /**
     * @throws \JsonMapper_Exception
     * @throws \Throwable
     */
    public function testHandlingWhenSubjectIsNull()
    {
        $senderEmail = $this->faker->email;

        // Make faker generate name without titles and suffixes
        $senderName = $this->faker->boolean ? $this->faker->firstName . ' ' . $this->faker->lastName : null;
        $from = $this->makeRFC822Address($senderEmail, $senderName);

        $toRecipients = $this->makeRecipients();
        $ccRecipients = $this->faker->boolean ? $this->makeRecipients() : null;

        $recipientEmail = $toRecipients[0]['address'];
        $externalMessageId = $this->faker->uuid . '@' . $this->faker->domainName;

        $headers = [
            ['Message-Id', '<' . $externalMessageId . '>'],
            ['To', $this->recipientsToRFC822String($toRecipients)],
        ];
        if (null !== $ccRecipients) {
            $headers[] = ['Cc', $this->recipientsToRFC822String($ccRecipients)];
        }

        $data = [
            'timestamp'          => (int)$this->faker->dateTime()->format('U'),
            'token'              => $this->faker->sha1,
            'signature'          => $this->faker->sha256,
            'domain'             => $this->faker->domainName,
            'subject'            => null,
            'sender'             => $senderEmail,
            'from'               => $from,
            'recipient'          => $recipientEmail,
            'body_plain'         => $this->faker->paragraph,
            'body_html'          => $this->faker->randomHtml(),
            'stripped_text'      => $this->faker->paragraph,
            'stripped_signature' => $this->faker->optional()->sentence,
            'stripped_html'      => $this->faker->optional()->randomHtml(),
            'message_headers'    => \GuzzleHttp\json_encode($headers),
        ];

        Queue::fake();

        $job = new HandleIncomingJobMessage($data);

        $job->handle($this->messagingService, $this->documentsService);

        /** @var Message $message */
        $message = Message::query()->where('external_system_message_id', $externalMessageId)
            ->firstOrFail();

        self::assertEquals($senderEmail, $message->from_address);
        self::assertEquals($senderName ?? $senderEmail, $message->from_name);
        self::assertEquals($data['subject'], null);
        self::assertEquals($data['stripped_text'], $message->message_body);

        Queue::assertPushedOn(
            'jobs',
            FindOrCreateOrActivateJobForIncomingMessage::class,
            function (FindOrCreateOrActivateJobForIncomingMessage $job) use ($message) {
                return $job->getMessageId() === $message->id;
            }
        );
    }

    /**
     * @throws \JsonMapper_Exception
     * @throws \Throwable
     */
    public function testHandlingWhenBodyIsNull()
    {
        $senderEmail = $this->faker->email;

        // Make faker generate name without titles and suffixes
        $senderName = $this->faker->boolean ? $this->faker->firstName . ' ' . $this->faker->lastName : null;
        $from = $this->makeRFC822Address($senderEmail, $senderName);

        $toRecipients = $this->makeRecipients();
        $ccRecipients = $this->faker->boolean ? $this->makeRecipients() : null;

        $recipientEmail = $toRecipients[0]['address'];
        $externalMessageId = $this->faker->uuid . '@' . $this->faker->domainName;

        $headers = [
            ['Message-Id', '<' . $externalMessageId . '>'],
            ['To', $this->recipientsToRFC822String($toRecipients)],
        ];
        if (null !== $ccRecipients) {
            $headers[] = ['Cc', $this->recipientsToRFC822String($ccRecipients)];
        }

        $data = [
            'timestamp'          => (int)$this->faker->dateTime()->format('U'),
            'token'              => $this->faker->sha1,
            'signature'          => $this->faker->sha256,
            'domain'             => $this->faker->domainName,
            'subject'            => $this->faker->word,
            'sender'             => $senderEmail,
            'from'               => $from,
            'recipient'          => $recipientEmail,
            'body_plain'         => null,
            'body_html'          => null,
            'stripped_text'      => null,
            'stripped_signature' => $this->faker->optional()->sentence,
            'stripped_html'      => $this->faker->optional()->randomHtml(),
            'message_headers'    => \GuzzleHttp\json_encode($headers),
        ];

        Queue::fake();

        $job = new HandleIncomingJobMessage($data);

        $job->handle($this->messagingService, $this->documentsService);

        /** @var Message $message */
        $message = Message::query()->where('external_system_message_id', $externalMessageId)
            ->firstOrFail();

        self::assertEquals($senderEmail, $message->from_address);
        self::assertEquals($senderName ?? $senderEmail, $message->from_name);
        self::assertEquals($data['subject'], $message->subject);
        self::assertEquals($data['stripped_text'], null);

        Queue::assertPushedOn(
            'jobs',
            FindOrCreateOrActivateJobForIncomingMessage::class,
            function (FindOrCreateOrActivateJobForIncomingMessage $job) use ($message) {
                return $job->getMessageId() === $message->id;
            }
        );
    }
}
